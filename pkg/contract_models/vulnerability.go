package models

type ByteCodeAnalyzeResult struct {
	AnalyzeAt       int64           `json:"analyze_at"`
	Vulnerabilities []Vulnerability `json:"vulnerabilities"`
}

type SourceCodeAnalyzeResult struct {
	AnalyzeAt       int64           `json:"analyze_at"`
	Vulnerabilities []Vulnerability `json:"vulnerabilities"`
}

type Vulnerability struct {
	Info string            `json:"info"`
	Type VulnerabilityType `json:"type"`
}

type VulnerabilityType struct {
	ID               int64  `json:"id"`
	Name             string `json:"name"`
	NameZH           string `json:"name_zh"`
	ShortDescription string `json:"short_description"`
	LongDescription  string `json:"long_description"`
	Level            Level  `json:"level"`
}

type Level uint8

const (
	UnknownLevel Level = 0
	HighLevel    Level = 1
	MiddleLevel  Level = 2
	LowLevel     Level = 3
	Warning      Level = 4
)

var VulnerabilityTypeUnknown VulnerabilityType = VulnerabilityType{
	ID:               0,
	Name:             "Unknown",
	NameZH:           "未知",
	ShortDescription: "未知漏洞",
	LongDescription:  "未知漏洞",
	Level:            UnknownLevel,
}

// CustomizeVulnerabilityType 注意：仅在定义一个不属于下列任何给出的漏洞类型时使用
func CustomizeVulnerabilityType(name string, level Level) VulnerabilityType {
	return VulnerabilityType{
		ID:    -1,
		Name:  name,
		Level: level,
	}
}

// VulnerabilityTypeFunctionDefaultVisibility SWC-100, https://swcregistry.io/docs/SWC-100
var VulnerabilityTypeFunctionDefaultVisibility VulnerabilityType = VulnerabilityType{
	ID:               100,
	Name:             "Function Default Visibility",
	NameZH:           "函数未指定可见性",
	ShortDescription: "Function Default Visibility",
	LongDescription:  "Functions that do not have a function visibility type specified are public by default. This can lead to a vulnerability if a developer forgot to set the visibility and a malicious user is able to make unauthorized or unintended state changes.",
	Level:            Warning,
}

// VulnerabilityTypeIntegerOverflowAndUnderflow SWC-101, https://swcregistry.io/docs/SWC-101
var VulnerabilityTypeIntegerOverflowAndUnderflow VulnerabilityType = VulnerabilityType{
	ID:               101,
	Name:             "Integer Overflow and Underflow",
	NameZH:           "整数溢出",
	ShortDescription: "Integer Overflow and Underflow",
	LongDescription:  "An overflow/underflow happens when an arithmetic operation reaches the maximum or minimum size of a type. For instance if a number is stored in the uint8 type, it means that the number is stored in a 8 bits unsigned number ranging from 0 to 2^8-1. In computer programming, an integer overflow occurs when an arithmetic operation attempts to create a numeric value that is outside of the range that can be represented with a given number of bits – either larger than the maximum or lower than the minimum representable value.",
	Level:            HighLevel,
}

// VulnerabilityTypeOutdatedCompilerVersion SWC-102, https://swcregistry.io/docs/SWC-102
var VulnerabilityTypeOutdatedCompilerVersion VulnerabilityType = VulnerabilityType{
	ID:               102,
	Name:             "Outdated Compiler Version",
	NameZH:           "编译器版本过老",
	ShortDescription: "Outdated Compiler Version",
	LongDescription:  "Using an outdated compiler version can be problematic especially if there are publicly disclosed bugs and issues that affect the current compiler version.",
	Level:            Warning,
}

// VulnerabilityTypeFloatingPragma SWC-103, https://swcregistry.io/docs/SWC-103
var VulnerabilityTypeFloatingPragma VulnerabilityType = VulnerabilityType{
	ID:               103,
	Name:             "Floating Pragma",
	NameZH:           "浮动的编译器版本",
	ShortDescription: "Floating Pragma",
	LongDescription:  "Contracts should be deployed with the same compiler version and flags that they have been tested with thoroughly. Locking the pragma helps to ensure that contracts do not accidentally get deployed using, for example, an outdated compiler version that might introduce bugs that affect the contract system negatively.",
	Level:            Warning,
}

// VulnerabilityTypeUncheckedCallReturnValue SWC-104, https://swcregistry.io/docs/SWC-104
var VulnerabilityTypeUncheckedCallReturnValue VulnerabilityType = VulnerabilityType{
	ID:               104,
	Name:             "Unchecked Call Return Value",
	NameZH:           "未检查返回值",
	ShortDescription: "Unchecked Call Return Value",
	LongDescription:  "The return value of a message call is not checked. Execution will resume even if the called contract throws an exception. If the call fails accidentally or an attacker forces the call to fail, this may cause unexpected behaviour in the subsequent program logic.",
	Level:            MiddleLevel,
}

// VulnerabilityTypeUnprotectedEtherWithdrawal SWC-105, https://swcregistry.io/docs/SWC-105
var VulnerabilityTypeUnprotectedEtherWithdrawal VulnerabilityType = VulnerabilityType{
	ID:               105,
	Name:             "Unprotected Ether Withdrawal",
	NameZH:           "无保护的以太币提现",
	ShortDescription: "Unprotected Ether Withdrawal",
	LongDescription:  "Due to missing or insufficient access controls, malicious parties can withdraw some or all Ether from the contract account.This bug is sometimes caused by unintentionally exposing initialization functions. By wrongly naming a function intended to be a constructor, the constructor code ends up in the runtime byte code and can be called by anyone to re-initialize the contract.",
	Level:            MiddleLevel,
}

// VulnerabilityTypeUnprotectedSELFDESTRUCTInstruction SWC-106, https://swcregistry.io/docs/SWC-106
var VulnerabilityTypeUnprotectedSELFDESTRUCTInstruction VulnerabilityType = VulnerabilityType{
	ID:               106,
	Name:             "UnprotectedSELFDESTRUCTInstruction",
	NameZH:           "无保护的自毁",
	ShortDescription: "UnprotectedSELFDESTRUCTInstruction",
	LongDescription:  "Due to missing or insufficient access controls, malicious parties can self-destruct the contract.",
	Level:            HighLevel,
}

// VulnerabilityTypeReentrancy SWC-107, https://swcregistry.io/docs/SWC-107
var VulnerabilityTypeReentrancy VulnerabilityType = VulnerabilityType{
	ID:               107,
	Name:             "Reentrancy",
	NameZH:           "重入",
	ShortDescription: "Reentrancy",
	LongDescription:  "One of the major dangers of calling external contracts is that they can take over the control flow. In the reentrancy attack (a.k.a. recursive call attack), a malicious contract calls back into the calling contract before the first invocation of the function is finished. This may cause the different invocations of the function to interact in undesirable ways.",
	Level:            HighLevel,
}

// VulnerabilityTypeStateVariableDefaultVisibility SWC-108, https://swcregistry.io/docs/SWC-108
var VulnerabilityTypeStateVariableDefaultVisibility VulnerabilityType = VulnerabilityType{
	ID:               108,
	Name:             "State Variable Default Visibility",
	NameZH:           "状态变量未指定可见性",
	ShortDescription: "State Variable Default Visibility",
	LongDescription:  "Labeling the visibility explicitly makes it easier to catch incorrect assumptions about who can access the variable.",
	Level:            Warning,
}

// VulnerabilityTypeUninitializedStoragePointer SWC-109, https://swcregistry.io/docs/SWC-109
var VulnerabilityTypeUninitializedStoragePointer VulnerabilityType = VulnerabilityType{
	ID:               109,
	Name:             "Uninitialized Storage Pointer",
	NameZH:           "未初始化的存储指针",
	ShortDescription: "Uninitialized Storage Pointer",
	LongDescription:  "Uninitialized local storage variables can point to unexpected storage locations in the contract, which can lead to intentional or unintentional vulnerabilities.",
	Level:            HighLevel,
}

// VulnerabilityTypeAssertViolation SWC-110, https://swcregistry.io/docs/SWC-110
var VulnerabilityTypeAssertViolation VulnerabilityType = VulnerabilityType{
	ID:               110,
	Name:             "Assert Violation",
	NameZH:           "assert不合规",
	ShortDescription: "Assert Violation",
	LongDescription:  "The Solidity assert() function is meant to assert invariants. Properly functioning code should never reach a failing assert statement. A reachable assertion can mean one of two things:1.A bug exists in the contract that allows it to enter an invalid state;2.The assert statement is used incorrectly, e.g. to validate inputs.",
	Level:            MiddleLevel,
}

// VulnerabilityTypeUseOfDeprecatedSolidityFunctions SWC-111, https://swcregistry.io/docs/SWC-111
var VulnerabilityTypeUseOfDeprecatedSolidityFunctions VulnerabilityType = VulnerabilityType{
	ID:               111,
	Name:             "Use of Deprecated Solidity Functions",
	NameZH:           "使用已废弃的solidity函数",
	ShortDescription: "Use of Deprecated Solidity Functions",
	LongDescription:  "Several functions and operators in Solidity are deprecated. Using them leads to reduced code quality. With new major versions of the Solidity compiler, deprecated functions and operators may result in side effects and compile errors.",
	Level:            LowLevel,
}

// VulnerabilityTypeDelegatecallToUntrustedCallee SWC-112, https://swcregistry.io/docs/SWC-112
var VulnerabilityTypeDelegatecallToUntrustedCallee VulnerabilityType = VulnerabilityType{
	ID:               112,
	Name:             "Delegatecall to Untrusted Callee",
	NameZH:           "不受信任的外部调用",
	ShortDescription: "Delegatecall to Untrusted Callee",
	LongDescription:  "There exists a special variant of a message call, named delegatecall which is identical to a message call apart from the fact that the code at the target address is executed in the context of the calling contract and msg.sender and msg.value do not change their values. This allows a smart contract to dynamically load code from a different address at runtime. Storage, current address and balance still refer to the calling contract.\n\nCalling into untrusted contracts is very dangerous, as the code at the target address can change any storage values of the caller and has full control over the caller's balance.",
	Level:            HighLevel,
}

// VulnerabilityTypeDoSWithFailedCall SWC-113, https://swcregistry.io/docs/SWC-113
var VulnerabilityTypeDoSWithFailedCall VulnerabilityType = VulnerabilityType{
	ID:               113,
	Name:             "DoS with Failed Call",
	NameZH:           "调用失败导致的拒绝服务",
	ShortDescription: "DoS with Failed Call",
	LongDescription:  "External calls can fail accidentally or deliberately, which can cause a DoS condition in the contract. To minimize the damage caused by such failures, it is better to isolate each external call into its own transaction that can be initiated by the recipient of the call. This is especially relevant for payments, where it is better to let users withdraw funds rather than push funds to them automatically (this also reduces the chance of problems with the gas limit).",
	Level:            MiddleLevel,
}

// VulnerabilityTypeTransactionOrderDependence SWC-114, https://swcregistry.io/docs/SWC-114
var VulnerabilityTypeTransactionOrderDependence VulnerabilityType = VulnerabilityType{
	ID:               114,
	Name:             "Transaction Order Dependence",
	NameZH:           "交易顺序依赖",
	ShortDescription: "Transaction Order Dependence",
	LongDescription:  "The Ethereum network processes transactions in blocks with new blocks getting confirmed around every 17 seconds. The miners look at transactions they have received and select which transactions to include in a block, based who has paid a high enough gas price to be included. Additionally, when transactions are sent to the Ethereum network they are forwarded to each node for processing. Thus, a person who is running an Ethereum node can tell which transactions are going to occur before they are finalized.A race condition vulnerability occurs when code depends on the order of the transactions submitted to it.\n\nThe simplest example of a race condition is when a smart contract give a reward for submitting information. Say a contract will give out 1 token to the first person who solves a math problem. Alice solves the problem and submits the answer to the network with a standard gas price. Eve runs an Ethereum node and can see the answer to the math problem in the transaction that Alice submitted to the network. So Eve submits the answer to the network with a much higher gas price and thus it gets processed and committed before Alice's transaction. Eve receives one token and Alice gets nothing, even though it was Alice who worked to solve the problem. A common way this occurs in practice is when a contract rewards people for calling out bad behavior in a protocol by giving a bad actor's deposit to the person who proved they were misbehaving.\n\nThe race condition that happens the most on the network today is the race condition in the ERC20 token standard. The ERC20 token standard includes a function called 'approve' which allows an address to approve another address to spend tokens on their behalf. Assume that Alice has approved Eve to spend n of her tokens, then Alice decides to change Eve's approval to m tokens. Alice submits a function call to approve with the value n for Eve. Eve runs a Ethereum node so knows that Alice is going to change her approval to m. Eve then submits a tranferFrom request sending n of Alice's tokens to herself, but gives it a much higher gas price than Alice's transaction. The transferFrom executes first so gives Eve n tokens and sets Eve's approval to zero. Then Alice's transaction executes and sets Eve's approval to m. Eve then sends those m tokens to herself as well. Thus Eve gets n + m tokens even thought she should have gotten at most max(n,m).",
	Level:            HighLevel,
}

// VulnerabilityTypeAuthorizationThroughTxOrigin SWC-115, https://swcregistry.io/docs/SWC-115
var VulnerabilityTypeAuthorizationThroughTxOrigin VulnerabilityType = VulnerabilityType{
	ID:               115,
	Name:             "Authorization through tx.origin",
	NameZH:           "使用tx.origin鉴权",
	ShortDescription: "Authorization through tx.origin",
	LongDescription:  "tx.origin is a global variable in Solidity which returns the address of the account that sent the transaction. Using the variable for authorization could make a contract vulnerable if an authorized account calls into a malicious contract. A call could be made to the vulnerable contract that passes the authorization check since tx.origin returns the original sender of the transaction which in this case is the authorized account.",
	Level:            HighLevel,
}

// VulnerabilityTypeBlockValuesAsAProxyForTime SWC-116, https://swcregistry.io/docs/SWC-116
var VulnerabilityTypeBlockValuesAsAProxyForTime VulnerabilityType = VulnerabilityType{
	ID:               116,
	Name:             "Block values as a proxy for time",
	NameZH:           "时间戳依赖",
	ShortDescription: "Block values as a proxy for time",
	LongDescription:  "Contracts often need access to time values to perform certain types of functionality. Values such as block.timestamp, and block.number can give you a sense of the current time or a time delta, however, they are not safe to use for most purposes.\n\nIn the case of block.timestamp, developers often attempt to use it to trigger time-dependent events. As Ethereum is decentralized, nodes can synchronize time only to some degree. Moreover, malicious miners can alter the timestamp of their blocks, especially if they can gain advantages by doing so. However, miners can't set a timestamp smaller than the previous one (otherwise the block will be rejected), nor can they set the timestamp too far ahead in the future. Taking all of the above into consideration, developers can't rely on the preciseness of the provided timestamp.\n\nAs for block.number, considering the block time on Ethereum is generally about 14 seconds, it's possible to predict the time delta between blocks. However, block times are not constant and are subject to change for a variety of reasons, e.g. fork reorganisations and the difficulty bomb. Due to variable block times, block.number should also not be relied on for precise calculations of time.",
	Level:            HighLevel,
}

// VulnerabilityTypeSignatureMalleability SWC-117, https://swcregistry.io/docs/SWC-117
var VulnerabilityTypeSignatureMalleability VulnerabilityType = VulnerabilityType{
	ID:               117,
	Name:             "Signature Malleability",
	NameZH:           "签名的非唯一性",
	ShortDescription: "Signature Malleability",
	LongDescription:  "The implementation of a cryptographic signature system in Ethereum contracts often assumes that the signature is unique, but signatures can be altered without the possession of the private key and still be valid. The EVM specification defines several so-called ‘precompiled’ contracts one of them being ecrecover which executes the elliptic curve public key recovery. A malicious user can slightly modify the three values v, r and s to create other valid signatures. A system that performs signature verification on contract level might be susceptible to attacks if the signature is part of the signed message hash. Valid signatures could be created by a malicious user to replay previously signed messages.",
	Level:            MiddleLevel,
}

// VulnerabilityTypeIncorrectConstructorName SWC-118, https://swcregistry.io/docs/SWC-118
var VulnerabilityTypeIncorrectConstructorName VulnerabilityType = VulnerabilityType{
	ID:               118,
	Name:             "Incorrect Constructor Name",
	NameZH:           "构造函数名错误",
	ShortDescription: "Incorrect Constructor Name",
	LongDescription:  "Constructors are special functions that are called only once during the contract creation. They often perform critical, privileged actions such as setting the owner of the contract. Before Solidity version 0.4.22, the only way of defining a constructor was to create a function with the same name as the contract class containing it. A function meant to become a constructor becomes a normal, callable function if its name doesn't exactly match the contract name. This behavior sometimes leads to security issues, in particular when smart contract code is re-used with a different name but the name of the constructor function is not changed accordingly.",
	Level:            HighLevel,
}

// VulnerabilityTypeShadowingStateVariables SWC-119, https://swcregistry.io/docs/SWC-119
var VulnerabilityTypeShadowingStateVariables VulnerabilityType = VulnerabilityType{
	ID:               119,
	Name:             "Shadowing State Variables",
	NameZH:           "影子状态变量",
	ShortDescription: "Shadowing State Variables",
	LongDescription:  "Solidity allows for ambiguous naming of state variables when inheritance is used. Contract A with a variable x could inherit contract B that also has a state variable x defined. This would result in two separate versions of x, one of them being accessed from contract A and the other one from contract B. In more complex contract systems this condition could go unnoticed and subsequently lead to security issues.\n\nShadowing state variables can also occur within a single contract when there are multiple definitions on the contract and function level.",
	Level:            HighLevel,
}

// VulnerabilityTypeWeakSourcesOfRandomnessFromChainAttributes SWC-120, https://swcregistry.io/docs/SWC-120
var VulnerabilityTypeWeakSourcesOfRandomnessFromChainAttributes VulnerabilityType = VulnerabilityType{
	ID:               120,
	Name:             "Weak Sources of Randomness from Chain Attributes",
	NameZH:           "弱随机值",
	ShortDescription: "Weak Sources of Randomness from Chain Attributes",
	LongDescription:  "Ability to generate random numbers is very helpful in all kinds of applications. One obvious example is gambling DApps, where pseudo-random number generator is used to pick the winner. However, creating a strong enough source of randomness in Ethereum is very challenging. For example, use of block.timestamp is insecure, as a miner can choose to provide any timestamp within a few seconds and still get his block accepted by others. Use of blockhash, block.difficulty and other fields is also insecure, as they're controlled by the miner. If the stakes are high, the miner can mine lots of blocks in a short time by renting hardware, pick the block that has required block hash for him to win, and drop all others.",
	Level:            HighLevel,
}

// VulnerabilityTypeMissingProtectionAgainstSignatureReplayAttacks SWC-121, https://swcregistry.io/docs/SWC-121
var VulnerabilityTypeMissingProtectionAgainstSignatureReplayAttacks VulnerabilityType = VulnerabilityType{
	ID:               121,
	Name:             "Missing Protection against Signature Replay Attacks",
	NameZH:           "未保护签名重放攻击",
	ShortDescription: "Missing Protection against Signature Replay Attacks",
	LongDescription:  "It is sometimes necessary to perform signature verification in smart contracts to achieve better usability or to save gas cost. A secure implementation needs to protect against Signature Replay Attacks by for example keeping track of all processed message hashes and only allowing new message hashes to be processed. A malicious user could attack a contract without such a control and get message hash that was sent by another user processed multiple times.",
	Level:            HighLevel,
}

// VulnerabilityTypeLackOfProperSignatureVerification SWC-122, https://swcregistry.io/docs/SWC-122
var VulnerabilityTypeLackOfProperSignatureVerification VulnerabilityType = VulnerabilityType{
	ID:               122,
	Name:             "Lack of Proper Signature Verification",
	NameZH:           "缺乏适当的签名验证",
	ShortDescription: "Lack of Proper Signature Verification",
	LongDescription:  "It is a common pattern for smart contract systems to allow users to sign messages off-chain instead of directly requesting users to do an on-chain transaction because of the flexibility and increased transferability that this provides. Smart contract systems that process signed messages have to implement their own logic to recover the authenticity from the signed messages before they process them further. A limitation for such systems is that smart contracts can not directly interact with them because they can not sign messages. Some signature verification implementations attempt to solve this problem by assuming the validity of a signed message based on other methods that do not have this limitation. An example of such a method is to rely on msg.sender and assume that if a signed message originated from the sender address then it has also been created by the sender address. This can lead to vulnerabilities especially in scenarios where proxies can be used to relay transactions.",
	Level:            MiddleLevel,
}

// VulnerabilityTypeRequirementViolation SWC-123, https://swcregistry.io/docs/SWC-123
var VulnerabilityTypeRequirementViolation VulnerabilityType = VulnerabilityType{
	ID:               123,
	Name:             "Requirement Violation",
	NameZH:           "require不合规",
	ShortDescription: "Requirement Violation",
	LongDescription:  "The Solidity require() construct is meant to validate external inputs of a function. In most cases, such external inputs are provided by callers, but they may also be returned by callees. In the former case, we refer to them as precondition violations. Violations of a requirement can indicate one of two possible issues:\n\nA bug exists in the contract that provided the external input.\nThe condition used to express the requirement is too strong.",
	Level:            Warning,
}

// VulnerabilityTypeWriteToArbitraryStorageLocation SWC-124, https://swcregistry.io/docs/SWC-124
var VulnerabilityTypeWriteToArbitraryStorageLocation VulnerabilityType = VulnerabilityType{
	ID:               124,
	Name:             "Write to Arbitrary Storage Location",
	NameZH:           "任意变量写入",
	ShortDescription: "Write to Arbitrary Storage Location",
	LongDescription:  "A smart contract's data (e.g., storing the owner of the contract) is persistently stored at some storage location (i.e., a key or address) on the EVM level. The contract is responsible for ensuring that only authorized user or contract accounts may write to sensitive storage locations. If an attacker is able to write to arbitrary storage locations of a contract, the authorization checks may easily be circumvented. This can allow an attacker to corrupt the storage; for instance, by overwriting a field that stores the address of the contract owner.",
	Level:            HighLevel,
}

// VulnerabilityTypeIncorrectInheritanceOrder SWC-125, https://swcregistry.io/docs/SWC-125
var VulnerabilityTypeIncorrectInheritanceOrder VulnerabilityType = VulnerabilityType{
	ID:               125,
	Name:             "Incorrect Inheritance Order",
	NameZH:           "不正确的继承顺序",
	ShortDescription: "Incorrect Inheritance Order",
	LongDescription:  "Solidity supports multiple inheritance, meaning that one contract can inherit several contracts. Multiple inheritance introduces ambiguity called Diamond Problem: if two or more base contracts define the same function, which one should be called in the child contract? Solidity deals with this ambiguity by using reverse C3 Linearization, which sets a priority between base contracts.\n\nThat way, base contracts have different priorities, so the order of inheritance matters. Neglecting inheritance order can lead to unexpected behavior.",
	Level:            LowLevel,
}

// VulnerabilityTypeInsufficientGasGriefing SWC-126, https://swcregistry.io/docs/SWC-126
var VulnerabilityTypeInsufficientGasGriefing VulnerabilityType = VulnerabilityType{
	ID:               126,
	Name:             "Insufficient Gas Griefing",
	NameZH:           "gas不足",
	ShortDescription: "Insufficient Gas Griefing",
	LongDescription:  "Insufficient gas griefing attacks can be performed on contracts which accept data and use it in a sub-call on another contract. If the sub-call fails, either the whole transaction is reverted, or execution is continued. In the case of a relayer contract, the user who executes the transaction, the 'forwarder', can effectively censor transactions by using just enough gas to execute the transaction, but not enough for the sub-call to succeed.",
	Level:            LowLevel,
}

// VulnerabilityTypeArbitraryJumpWithFunctionTypeVariable SWC-127, https://swcregistry.io/docs/SWC-127
var VulnerabilityTypeArbitraryJumpWithFunctionTypeVariable VulnerabilityType = VulnerabilityType{
	ID:               127,
	Name:             "Arbitrary Jump with Function Type Variable",
	NameZH:           "函数类型变量任意跳转",
	ShortDescription: "Arbitrary Jump with Function Type Variable",
	LongDescription:  "Solidity supports function types. That is, a variable of function type can be assigned with a reference to a function with a matching signature. The function saved to such variable can be called just like a regular function.\n\nThe problem arises when a user has the ability to arbitrarily change the function type variable and thus execute random code instructions. As Solidity doesn't support pointer arithmetics, it's impossible to change such variable to an arbitrary value. However, if the developer uses assembly instructions, such as mstore or assign operator, in the worst case scenario an attacker is able to point a function type variable to any code instruction, violating required validations and required state changes.",
	Level:            HighLevel,
}

// VulnerabilityTypeDoSWithBlockGasLimit SWC-128, https://swcregistry.io/docs/SWC-128
var VulnerabilityTypeDoSWithBlockGasLimit VulnerabilityType = VulnerabilityType{
	ID:               128,
	Name:             "DoS With Block Gas Limit",
	NameZH:           "区块gas限制导致的拒绝服务",
	ShortDescription: "DoS With Block Gas Limit",
	LongDescription:  "When smart contracts are deployed or functions inside them are called, the execution of these actions always requires a certain amount of gas, based of how much computation is needed to complete them. The Ethereum network specifies a block gas limit and the sum of all transactions included in a block can not exceed the threshold.\n\nProgramming patterns that are harmless in centralized applications can lead to Denial of Service conditions in smart contracts when the cost of executing a function exceeds the block gas limit. Modifying an array of unknown size, that increases in size over time, can lead to such a Denial of Service condition.",
	Level:            LowLevel,
}

// VulnerabilityTypeTypographicalError SWC-129, https://swcregistry.io/docs/SWC-129
var VulnerabilityTypeTypographicalError VulnerabilityType = VulnerabilityType{
	ID:               129,
	Name:             "Typographical Error",
	NameZH:           "笔误",
	ShortDescription: "Typographical Error",
	LongDescription:  "A typographical error can occur for example when the intent of a defined operation is to sum a number to a variable (+=) but it has accidentally been defined in a wrong way (=+), introducing a typo which happens to be a valid operator. Instead of calculating the sum it initializes the variable again.\n\nThe unary + operator is deprecated in new solidity compiler versions.",
	Level:            LowLevel,
}

// VulnerabilityTypeRightToLeftOverrideControlCharacter SWC-130, https://swcregistry.io/docs/SWC-130
var VulnerabilityTypeRightToLeftOverrideControlCharacter VulnerabilityType = VulnerabilityType{
	ID:               130,
	Name:             "Right-To-Left-Override control character (U+202E)",
	NameZH:           "使用反向控制字符(U+202E)",
	ShortDescription: "Right-To-Left-Override control character (U+202E)",
	LongDescription:  "Malicious actors can use the Right-To-Left-Override unicode character to force RTL text rendering and confuse users as to the real intent of a contract.",
	Level:            HighLevel,
}

// VulnerabilityTypePresenceOfUnusedVariables SWC-131, https://swcregistry.io/docs/SWC-131
var VulnerabilityTypePresenceOfUnusedVariables VulnerabilityType = VulnerabilityType{
	ID:               131,
	Name:             "Presence of unused variables",
	NameZH:           "存在未使用的变量",
	ShortDescription: "Presence of unused variables",
	LongDescription:  "Unused variables are allowed in Solidity and they do not pose a direct security issue. It is best practice though to avoid them as they can:\n\ncause an increase in computations (and unnecessary gas consumption)\nindicate bugs or malformed data structures and they are generally a sign of poor code quality\ncause code noise and decrease readability of the code",
	Level:            Warning,
}

// VulnerabilityTypeUnexpectedEtherBalance SWC-132, https://swcregistry.io/docs/SWC-132
var VulnerabilityTypeUnexpectedEtherBalance VulnerabilityType = VulnerabilityType{
	ID:               132,
	Name:             "Unexpected Ether balance",
	NameZH:           "依赖于以太币余额的逻辑",
	ShortDescription: "Unexpected Ether balance",
	LongDescription:  "Contracts can behave erroneously when they strictly assume a specific Ether balance. It is always possible to forcibly send ether to a contract (without triggering its fallback function), using selfdestruct, or by mining to the account. In the worst case scenario this could lead to DOS conditions that might render the contract unusable.",
	Level:            MiddleLevel,
}

// VulnerabilityTypeHashCollisionsWithMultipleVariableLengthArguments SWC-133, https://swcregistry.io/docs/SWC-133
var VulnerabilityTypeHashCollisionsWithMultipleVariableLengthArguments VulnerabilityType = VulnerabilityType{
	ID:               133,
	Name:             "Hash Collisions With Multiple Variable Length Arguments",
	NameZH:           "变长参数导致的哈希冲突",
	ShortDescription: "Hash Collisions With Multiple Variable Length Arguments",
	LongDescription:  "Using abi.encodePacked() with multiple variable length arguments can, in certain situations, lead to a hash collision. Since abi.encodePacked() packs all elements in order regardless of whether they're part of an array, you can move elements between arrays and, so long as all elements are in the same order, it will return the same encoding. In a signature verification situation, an attacker could exploit this by modifying the position of elements in a previous function call to effectively bypass authorization.",
	Level:            HighLevel,
}

// VulnerabilityTypeMessageCallWithHardcodedGasAmount SWC-134, https://swcregistry.io/docs/SWC-134
var VulnerabilityTypeMessageCallWithHardcodedGasAmount VulnerabilityType = VulnerabilityType{
	ID:               134,
	Name:             "Message call with hardcoded gas amount",
	NameZH:           "硬编码gas用量的消息调用",
	ShortDescription: "Message call with hardcoded gas amount",
	LongDescription:  "The transfer() and send() functions forward a fixed amount of 2300 gas. Historically, it has often been recommended to use these functions for value transfers to guard against reentrancy attacks. However, the gas cost of EVM instructions may change significantly during hard forks which may break already deployed contract systems that make fixed assumptions about gas costs. For example. EIP 1884 broke several existing smart contracts due to a cost increase of the SLOAD instruction.",
	Level:            MiddleLevel,
}

// VulnerabilityTypeCodeWithNoEffects SWC-135, https://swcregistry.io/docs/SWC-135
var VulnerabilityTypeCodeWithNoEffects VulnerabilityType = VulnerabilityType{
	ID:               135,
	Name:             "Code With No Effects",
	NameZH:           "无效代码",
	ShortDescription: "Code With No Effects",
	LongDescription:  "In Solidity, it's possible to write code that does not produce the intended effects. Currently, the solidity compiler will not return a warning for effect-free code. This can lead to the introduction of \"dead\" code that does not properly performing an intended action.\n\nFor example, it's easy to miss the trailing parentheses in msg.sender.call.value(address(this).balance)(\"\");, which could lead to a function proceeding without transferring funds to msg.sender. Although, this should be avoided by checking the return value of the call.",
	Level:            Warning,
}

// VulnerabilityTypeUnencryptedPrivateDataOnChain SWC-136, https://swcregistry.io/docs/SWC-136
var VulnerabilityTypeUnencryptedPrivateDataOnChain VulnerabilityType = VulnerabilityType{
	ID:               136,
	Name:             "Unencrypted Private Data On-Chain",
	NameZH:           "未加密的链上私人数据",
	ShortDescription: "Unencrypted Private Data On-Chain",
	LongDescription:  "It is a common misconception that private type variables cannot be read. Even if your contract is not published, attackers can look at contract transactions to determine values stored in the state of the contract. For this reason, it's important that unencrypted private data is not stored in the contract code or state.",
	Level:            Warning,
}

// VulnerabilityTypeArbitraryModifyOwnership A new vulnerability type created by zhangyiqiong
var VulnerabilityTypeArbitraryModifyOwnership VulnerabilityType = VulnerabilityType{
	ID:               137,
	Name:             "Ownership Modified Arbitrarily",
	NameZH:           "所有者权限可以被任意修改",
	ShortDescription: "Ownership Modified Arbitrarily",
	LongDescription:  "Ownership can be modified arbitrarily",
	Level:            HighLevel,
}

// VulnerabilityTypeArbitraryTransfer A new vulnerability type created by zhangyiqiong
var VulnerabilityTypeArbitraryTransfer VulnerabilityType = VulnerabilityType{
	ID:               138,
	Name:             "Transfer Arbitrarily",
	NameZH:           "任意转账",
	ShortDescription: "Transfer Arbitrarily",
	LongDescription:  "Can be arbitrarily transferred out of ether",
	Level:            HighLevel,
}

// VulnerabilityTypeABIEncoderV2Array Defined by slither, https://github.com/crytic/slither/wiki/Detector-Documentation
var VulnerabilityTypeABIEncoderV2Array VulnerabilityType = VulnerabilityType{
	ID:               139,
	Name:             "ABIEncoderV2Array",
	NameZH:           "使用abi.encode操作二维数组",
	ShortDescription: "ABIEncoderV2Array",
	LongDescription:  "solc versions 0.4.7-0.5.9 contain a compiler bug leading to incorrect ABI encoder usage.",
	Level:            HighLevel,
}

// VulnerabilityTypeArrayByReference Defined by slither, https://github.com/crytic/slither/wiki/Detector-Documentation
var VulnerabilityTypeArrayByReference VulnerabilityType = VulnerabilityType{
	ID:               140,
	Name:             "Array By Reference",
	NameZH:           "按值修改存储数组",
	ShortDescription: "Modify Array By Reference",
	LongDescription:  "Detect arrays passed to a function that expects reference to a storage array. Ensure the correct usage of memory and storage in the function parameters. Make all the locations explicit",
	Level:            HighLevel,
}

// VulnerabilityTypeIncorrectShift Defined by slither, https://github.com/crytic/slither/wiki/Detector-Documentation
var VulnerabilityTypeIncorrectShift VulnerabilityType = VulnerabilityType{
	ID:               141,
	Name:             "Incorrect Shift",
	NameZH:           "移位指令中参数顺序不正确",
	ShortDescription: "Incorrect Shift",
	LongDescription:  "Detect if the values in a shift operation are reversed.",
	Level:            HighLevel,
}

// VulnerabilityTypeMultipleConstructors Defined by slither, https://github.com/crytic/slither/wiki/Detector-Documentation
var VulnerabilityTypeMultipleConstructors VulnerabilityType = VulnerabilityType{
	ID:               142,
	Name:             "Multiple Constructors",
	NameZH:           "多个构造函数",
	ShortDescription: "Multiple Constructors",
	LongDescription:  "Detect multiple constructor definitions in the same contract (using new and old schemes).",
	Level:            HighLevel,
}

// VulnerabilityTypeNameReused Defined by slither, https://github.com/crytic/slither/wiki/Detector-Documentation
var VulnerabilityTypeNameReused VulnerabilityType = VulnerabilityType{
	ID:               143,
	Name:             "Name Reused",
	NameZH:           "合约名称重复使用",
	ShortDescription: "Contract Name Reused",
	LongDescription:  "If a codebase has two contracts the similar names, the compilation artifacts will not contain one of the contracts with the duplicate name.",
	Level:            HighLevel,
}

// VulnerabilityTypePublicMappingsNested Defined by slither, https://github.com/crytic/slither/wiki/Detector-Documentation
var VulnerabilityTypePublicMappingsNested VulnerabilityType = VulnerabilityType{
	ID:               144,
	Name:             "Public Mappings Nested",
	NameZH:           "具有嵌套变量的 public mapping",
	ShortDescription: "Public Mappings Nested",
	LongDescription:  "Prior to Solidity 0.5, a public mapping with nested structures returned incorrect values.",
	Level:            HighLevel,
}

// VulnerabilityTypeUnprotectedUpgrade Defined by slither, https://github.com/crytic/slither/wiki/Detector-Documentation
var VulnerabilityTypeUnprotectedUpgrade VulnerabilityType = VulnerabilityType{
	ID:               145,
	Name:             "Unprotected Upgrade",
	NameZH:           "不受保护的合约升级",
	ShortDescription: "Unprotected Upgrade",
	LongDescription:  "Detects logic contract that can be destructed.",
	Level:            HighLevel,
}

// VulnerabilityTypeArrayLengthAssignment Defined by slither, https://github.com/crytic/slither/wiki/Detector-Documentation
var VulnerabilityTypeArrayLengthAssignment VulnerabilityType = VulnerabilityType{
	ID:               146,
	Name:             "Array Length Assignment",
	NameZH:           "数组长度被任意分配",
	ShortDescription: "Array Length Assignment",
	LongDescription:  "Detects the direct assignment of an array's length. Do not allow array lengths to be set directly set; instead, opt to add values as needed. Otherwise, thoroughly review the contract to ensure a user-controlled variable cannot reach an array length assignment.",
	Level:            HighLevel,
}

// VulnerabilityTypeMsgValueInsideLoop Defined by slither, https://github.com/crytic/slither/wiki/Detector-Documentation
var VulnerabilityTypeMsgValueInsideLoop VulnerabilityType = VulnerabilityType{
	ID:               147,
	Name:             "Msg Value Inside A Loop",
	NameZH:           "循环内多次调用msg.value",
	ShortDescription: "Msg Value Inside A Loop",
	LongDescription:  "Detect the use of msg.value inside a loop. Track msg.value through a local variable and decrease its amount on every iteration/usage.",
	Level:            HighLevel,
}

// VulnerabilityTypeStorageSignedIntegerArray Defined by slither, https://github.com/crytic/slither/wiki/Detector-Documentation
var VulnerabilityTypeStorageSignedIntegerArray VulnerabilityType = VulnerabilityType{
	ID:               148,
	Name:             "Storage Signed Integer Array",
	NameZH:           "数组中存储有符号整数",
	ShortDescription: "Storage Signed Integer Array",
	LongDescription:  "solc versions 0.4.7-0.5.10 contain a compiler bug leading to incorrect values in signed integer arrays.",
	Level:            HighLevel,
}

// VulnerabilityTypeDangerousEnumConversion Defined by slither, https://github.com/crytic/slither/wiki/Detector-Documentation
var VulnerabilityTypeDangerousEnumConversion VulnerabilityType = VulnerabilityType{
	ID:               149,
	Name:             "Dangerous enum conversion",
	NameZH:           "危险的枚举转换",
	ShortDescription: "Dangerous enum conversion",
	LongDescription:  "Detect out-of-range enum conversion (solc < 0.4.5).",
	Level:            MiddleLevel,
}

// VulnerabilityTypeIncorrectERC20Interface Defined by slither, https://github.com/crytic/slither/wiki/Detector-Documentation
var VulnerabilityTypeIncorrectERC20Interface VulnerabilityType = VulnerabilityType{
	ID:               150,
	Name:             "Incorrect ERC20 interface",
	NameZH:           "ERC20接口不规范",
	ShortDescription: "Incorrect ERC20 interface",
	LongDescription:  "Incorrect return values for ERC20 functions. A contract compiled with Solidity > 0.4.22 interacting with these functions will fail to execute them, as the return value is missing.",
	Level:            MiddleLevel,
}

// VulnerabilityTypeIncorrectERC721Interface Defined by slither, https://github.com/crytic/slither/wiki/Detector-Documentation
var VulnerabilityTypeIncorrectERC721Interface VulnerabilityType = VulnerabilityType{
	ID:               151,
	Name:             "Incorrect ERC721 interface",
	NameZH:           "ERC721接口不规范",
	ShortDescription: "Incorrect ERC721 interface",
	LongDescription:  "Incorrect return values for ERCERC functions. A contract compiled with Solidity > 0.4.22 interacting with these functions will fail to execute them, as the return value is missing.",
	Level:            MiddleLevel,
}

// VulnerabilityTypeDangerousStrictEqualities Defined by slither, https://github.com/crytic/slither/wiki/Detector-Documentation
var VulnerabilityTypeDangerousStrictEqualities VulnerabilityType = VulnerabilityType{
	ID:               152,
	Name:             "Dangerous strict equalities",
	NameZH:           "危险的严格相等",
	ShortDescription: "Dangerous strict equalities",
	LongDescription:  "Use of strict equalities that can be easily manipulated by an attacker. Don't use strict equality to determine if an account has enough Ether or tokens.",
	Level:            MiddleLevel,
}

// VulnerabilityTypeContractsThatLockEther Defined by slither, https://github.com/crytic/slither/wiki/Detector-Documentation
var VulnerabilityTypeContractsThatLockEther VulnerabilityType = VulnerabilityType{
	ID:               153,
	Name:             "Contracts that lock Ether",
	NameZH:           "以太币锁定",
	ShortDescription: "Contracts that lock Ether",
	LongDescription:  "Contract with a payable function, but without a withdrawal capacity.",
	Level:            MiddleLevel,
}

// VulnerabilityTypeMappingDeletion Defined by slither, https://github.com/crytic/slither/wiki/Detector-Documentation
var VulnerabilityTypeMappingDeletion VulnerabilityType = VulnerabilityType{
	ID:               154,
	Name:             "Deletion on mapping containing a structure",
	NameZH:           "删除 mapping",
	ShortDescription: "Deletion on mapping containing a structure",
	LongDescription:  "A deletion in a structure containing a mapping will not delete the mapping (see the Solidity documentation). The remaining data may be used to compromise the contract. Use a lock mechanism instead of a deletion to disable structure containing a mapping.",
	Level:            MiddleLevel,
}

// VulnerabilityTypeTautologyOrContradiction Defined by slither, https://github.com/crytic/slither/wiki/Detector-Documentation
var VulnerabilityTypeTautologyOrContradiction VulnerabilityType = VulnerabilityType{
	ID:               155,
	Name:             "Tautology or contradiction",
	NameZH:           "条件重复或矛盾",
	ShortDescription: "Tautology or contradiction",
	LongDescription:  "Detects expressions that are tautologies or contradictions.",
	Level:            MiddleLevel,
}

// VulnerabilityTypeWriteAfterWrite Defined by slither, https://github.com/crytic/slither/wiki/Detector-Documentation
var VulnerabilityTypeWriteAfterWrite VulnerabilityType = VulnerabilityType{
	ID:               156,
	Name:             "Write after write",
	NameZH:           "未使用的写入",
	ShortDescription: "Write after write",
	LongDescription:  "Detects variables that are written but never read and written again.\n\n",
	Level:            MiddleLevel,
}

// VulnerabilityTypeMisuseOfBooleanConstant Defined by slither, https://github.com/crytic/slither/wiki/Detector-Documentation
var VulnerabilityTypeMisuseOfBooleanConstant VulnerabilityType = VulnerabilityType{
	ID:               157,
	Name:             "Misuse of a Boolean constant",
	NameZH:           "bool 值误用",
	ShortDescription: "Misuse of a Boolean constant",
	LongDescription:  "Detects the misuse of a Boolean constant.",
	Level:            MiddleLevel,
}

// VulnerabilityTypeConstantFunctionAsm Defined by slither, https://github.com/crytic/slither/wiki/Detector-Documentation
var VulnerabilityTypeConstantFunctionAsm VulnerabilityType = VulnerabilityType{
	ID:               158,
	Name:             "Constant functions using assembly code",
	NameZH:           "未使用 static call 的常量函数",
	ShortDescription: "Constant functions using assembly code",
	LongDescription:  "Functions declared as constant/pure/view using assembly code.\n\nconstant/pure/view was not enforced prior to Solidity 0.5. Starting from Solidity 0.5, a call to a constant/pure/view function uses the STATICCALL opcode, which reverts in case of state modification.\n\nAs a result, a call to an incorrectly labeled function may trap a contract compiled with Solidity 0.5.",
	Level:            MiddleLevel,
}

// VulnerabilityTypeConstantFunctionsState Defined by slither, https://github.com/crytic/slither/wiki/Detector-Documentation
var VulnerabilityTypeConstantFunctionsState VulnerabilityType = VulnerabilityType{
	ID:               159,
	Name:             "Constant functions changing the state",
	NameZH:           "改变状态变量的常量函数",
	ShortDescription: "Constant functions changing the state",
	LongDescription:  "Functions declared as constant/pure/view change the state.\n\nconstant/pure/view was not enforced prior to Solidity 0.5. Starting from Solidity 0.5, a call to a constant/pure/view function uses the STATICCALL opcode, which reverts in case of state modification.\n\nAs a result, a call to an incorrectly labeled function may trap a contract compiled with Solidity 0.5.",
	Level:            MiddleLevel,
}

// VulnerabilityTypeDivideBeforeMultiply Defined by slither, https://github.com/crytic/slither/wiki/Detector-Documentation
var VulnerabilityTypeDivideBeforeMultiply VulnerabilityType = VulnerabilityType{
	ID:               160,
	Name:             "Divide before multiply",
	NameZH:           "乘前除",
	ShortDescription: "Divide before multiply",
	LongDescription:  "Solidity integer division might truncate. As a result, performing multiplication before division can sometimes avoid loss of precision.\n\n",
	Level:            MiddleLevel,
}

// VulnerabilityTypeReusedBaseConstructors Defined by slither, https://github.com/crytic/slither/wiki/Detector-Documentation
var VulnerabilityTypeReusedBaseConstructors VulnerabilityType = VulnerabilityType{
	ID:               161,
	Name:             "Reused base constructors",
	NameZH:           "构造函数重用",
	ShortDescription: "Reused base constructors",
	LongDescription:  "Detects if the same base constructor is called with arguments from two different locations in the same inheritance hierarchy.",
	Level:            MiddleLevel,
}

// VulnerabilityTypeUnusedReturn Defined by slither, https://github.com/crytic/slither/wiki/Detector-Documentation
var VulnerabilityTypeUnusedReturn VulnerabilityType = VulnerabilityType{
	ID:               162,
	Name:             "Unused return",
	NameZH:           "未使用的返回值",
	ShortDescription: "Unused return",
	LongDescription:  "The return value of an external call is not stored in a local or state variable.",
	Level:            MiddleLevel,
}
